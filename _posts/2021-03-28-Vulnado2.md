---
layout: post
title: "Vulnado Parte 2"
date: 2021-03-28 13:37:00 -0300 
categories: blog
layout: post
---

‚ÄúVulnado, Ownado? WTF!? - Parte 2"
<!--more-->

## XSS

Agora que foi poss√≠vel realizar o login alterando a senha de qualquer usu√°rio via SQLi ou utilizando as senhas expostas no c√≥digo, vemos uma p√°gina de coment√°rios a ideia dessa parte do post √© explicar o porque foi poss√≠vel realizar um XSS.

### Front-end

Voc√™ j√° parou para analisar as entranhas do javascript<br>quando clica em um bot√£o `Submit`? Bom, de vez enquando faz bem.. hehe ü§ì<br>
Em casos de **DOM XSS** por exemplo analisar como √© processada sua request, pode levar a descoberta dessa vulnerabilidade e de outras qua acontecem no <i>client-side</i>.<br>

Nesse caso aqui a vulnerabilidade est√° no <i>Server-side</i>, por√©m irei mostrar como podemos debugar e como isso pode ser √∫til em alguns casos.

Olhando o c√≥digo javascript pelo "Developer Tools", foi poss√≠vel identificar as fun√ß√µes que realizam as principais fun√ß√µes da p√°gina de coment√°rios e na linha 41 eu setei um **breakpoint**.

<br>
<img src="/assets/img/Vulnado-3.png">
<br>

> Conseguimos descobrir outros endpoints, como s√£o feitas as requests, se existe alguma obfusca√ß√£o, encontrar keys, tokens, etc.. E voc√™ passa a entender melhor como funciona a aplica√ß√£o em si. "Nunca subestime o client-side". üòâ Temos um **"Debugger"** no navegador, porque n√£o usa-lo?

<br>
<img src="/assets/img/Vulnado-4.png">
<br>

### Back-end

Vamos analisar todas as prote√ß√µes que n√£o foram implementadas no back-end. :D

##### CommentsController.java

```java
@CrossOrigin(origins = "*")
@RequestMapping(value = "/comments", method = RequestMethod.POST, produces = "application/json", consumes = "application/json")
Comment createComment(@RequestHeader(value="x-auth-token") String token, @RequestBody CommentRequest input) {
return Comment.create(input.username, input.body);
}
```

Aqui √© poss√≠vel perceber que a aplica√ß√£o envia o CORS como **"*"**, no `/comments` o que seria um problema se n√£o fosse pelo header **"x-auth-token"**. Uma vez que o CSRF n√£o √© poss√≠vel quando tem que enviar um header como parte de sua autentica√ß√£o.

##### Comment.java

```java
public static Comment create(String username, String body){
long time = new Date().getTime();
Timestamp timestamp = new Timestamp(time);
Comment comment = new Comment(UUID.randomUUID().toString(), username, body, timestamp);
try {
    if (comment.commit()) {
    return comment;
    } else {
    throw new BadRequest("Unable to save comment");
    }
} catch (Exception e) {
    throw new ServerError(e.getMessage());
    }
}
```
Olhando as defini√ß√µes da classe <i>"Comments"</i>, vemos que ela recebe o usu√°rio e a mensagem, cria um timestamp e concatena com um **"UUID"** r√¢ndomico.

Logo em seguida o coment√°rio √© postado, sem nenhuma valida√ß√£o no coment√°rio, por isso foi poss√≠vel trigar um XSS com um simples payload:<br> 
`<img src=1 onerror="alert(1337)">`.

[Parte 3](../../../2021/03/30/Vulnado3.html)